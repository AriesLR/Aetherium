@using System;
@using System.Diagnostics;
@using System.Threading.Tasks;
@using Aetherium.Components.Pages;

<div class="container processcontainer">
    <div class="row">
        <div class="col">
            <div class="process-monitor">
                <span class="bi bi-cpu-fill-process-monitor" aria-hidden="true" ></span>
                <span class="process-monitor-labeltext">CPU <br /> Usage</span>
                <span class="process-monitor-usagetext">@resourceMonitor?.CpuUsage%</span>
            </div>
        </div>
        <div class="w-100"></div>
        <div class="col">
            <div class="process-monitor">
                <span class="bi bi-memory-process-monitor" aria-hidden="true" height="32" width="32"></span>
                <span class="process-monitor-labeltext">Memory <br /> Usage</span>
                <span class="process-monitor-usagetext">@resourceMonitor?.MemoryUsageMB MB</span>
            </div>
        </div>
    </div>
</div>

@code {
    private ResourceMonitor? resourceMonitor;

    protected override async Task OnInitializedAsync()
    {
        await WaitForProcessStart();
    }

    private async Task WaitForProcessStart()
    {
        while (true)
        {
            // Wait until the server process is started
            while (Server.serverProcess == null || Server.serverProcess.HasExited)
            {
                await Task.Delay(TimeSpan.FromSeconds(1)); // Delay for 1 second before checking again
            }

            // Once the process starts, initialize and start monitoring
            resourceMonitor = new ResourceMonitor(UpdateState); // Pass a reference to the UpdateState method
            await resourceMonitor.StartMonitoring(Server.serverProcess, 1); // Monitor every 1 second

            // Wait until the server process is closed
            while (Server.serverProcess != null && !Server.serverProcess.HasExited)
            {
                await Task.Delay(TimeSpan.FromSeconds(1)); // Delay for 1 second before checking again
            }

            // Stop monitoring when the server process is closed
            resourceMonitor.Dispose();
        }
    }


    public void UpdateState()
    {
        StateHasChanged(); // Call StateHasChanged method to update the UI
    }

    public class ResourceMonitor : IDisposable
    {
        private Process? process;
        private bool isMonitoring;
        private readonly Action updateStateAction;

        private PerformanceCounter cpuCounter;
        private PerformanceCounter ramCounter;

        public float CpuUsage { get; private set; }
        public float MemoryUsageMB { get; private set; }

        public ResourceMonitor(Action updateStateAction)
        {
            this.updateStateAction = updateStateAction;

            cpuCounter = new PerformanceCounter("Process", "% Processor Time", Server.serverProcess?.ProcessName);
            ramCounter = new PerformanceCounter("Process", "Working Set", Server.serverProcess?.ProcessName);
        }

        public async Task StartMonitoring(Process process, int intervalSeconds)
        {
            if (isMonitoring) return; // If already monitoring, do nothing
            isMonitoring = true;

            this.process = process;

            while (isMonitoring)
            {
                await Task.Delay(TimeSpan.FromSeconds(intervalSeconds)); // Wait for the specified interval

                if (Server.serverProcess == null || Server.serverProcess.HasExited)
                {
                    Console.WriteLine("Process is not running or has exited.");
                    StopMonitoring(); // Stop monitoring if the process has exited
                    return;
                }

                // Get CPU usage
                CpuUsage = (int)cpuCounter.NextValue() / Environment.ProcessorCount;

                // Get memory usage
                MemoryUsageMB = (int)(ramCounter.NextValue() / (1024f * 1024f)); // Convert bytes to megabytes and cast to int

                // Call the updateStateAction to update the UI
                updateStateAction();
            }
        }

        public void StopMonitoring()
        {
            isMonitoring = false;
            process = null;
        }

        public void Dispose()
        {
            cpuCounter.Dispose();
            ramCounter.Dispose();
        }
    }
}
